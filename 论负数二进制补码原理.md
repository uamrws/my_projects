## 负数二进制补码由来

以下我们以8bit的 int8 来说明补码原理

int8 的范围按二进制表示为 0000 0000-1111 1111 (共256个数字)

### 1。如果是你---你会如何设计负数的表示

在现代计算机中，所有数据都是通过高低电位来模拟，也就是我们只有也就是0，1两个数字来使用，也就是说
我们想要表示负数，只能通过0，1两个当中的一个来表示。

假设我们按照以下方式来设计负数

- 我们使用1来表示负号，也就是0000 0001表示正数1，1000 0001来表示负数，其他依次类推

乍一看，很合理，非常完美的设计，正数负数，都表示出来
0...127 的负数 -0...-127全部表示出来了，似乎没有什么不正常

但其实有很多不合理的地方
- 0 的表示有两个，分别是1000 0000 和0000 0000
- 负数和正数相加，0000 0001 + 1000 0001 = 1000 0010 ，会得出-2的答案

很显然上面的问题可以看出设计似乎除了一些问题

问题出在哪儿？
正数的表示肯定是毫无疑问的 0...127没有问题
那么毫无意为负数的表现形式不对

那如何去修改呢

既然正数表示是正确的，那么要使得 1 + -1 ==0000 0000，
我们可以通过进位溢出及用9位 1 0000 0000 - 0000 0001 = 1111 1111 来表示负数
依次类推出所有的二进制负数
这样计算出来的所有二进制负数 其最高位都为1
其中 128（1000 0000）较为特殊 1 0000 0000 - 1000 0000 = 1000 0000
由于它的高位是1 于是我们约定1000 0000 为 -128

这样设计相比之前的设计就合理了很多

那么这与我们今天讨论的补码机制有什么关系呢

补码：二进制负数的表现为 原数取反后加1

还是int8为例
一个int8二进制数字取反
实际就是用 1111 1111 去减去 这个数

